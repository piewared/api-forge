"""Type stubs for controller module.

This file is AUTO-GENERATED by running:
    python -m src.infra.k8s.controller

Do not edit manually. Regenerate after updating KubernetesController.
Dataclasses are automatically extracted from source using AST parsing.
"""

from __future__ import annotations

from abc import ABC
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path

__all__ = [
    "CommandResult",
    "PodInfo",
    "ReplicaSetInfo",
    "JobInfo",
    "ServiceInfo",
    "ClusterIssuerStatus",
    "KubernetesController",
    "KubernetesControllerSync",
]

# =============================================================================
# Data Types (AUTO-EXTRACTED)
# =============================================================================

@dataclass
class CommandResult:
    """Result of a command execution."""

    success: bool
    stdout: str = ""
    stderr: str = ""
    returncode: int = 0

@dataclass
class PodInfo:
    """Information about a Kubernetes pod."""

    name: str
    status: str
    restarts: int = 0
    creation_timestamp: str = ""
    job_owner: str = ""
    ip: str = ""
    node: str = ""

@dataclass
class ReplicaSetInfo:
    """Information about a Kubernetes ReplicaSet."""

    name: str
    replicas: int
    revision: str = ""
    created_at: datetime | None = None
    owner_deployment: str | None = None

@dataclass
class JobInfo:
    """Information about a Kubernetes Job."""

    name: str
    status: str

@dataclass
class ServiceInfo:
    """Information about a Kubernetes Service."""

    name: str
    type: str
    cluster_ip: str
    external_ip: str = ""
    ports: str = ""

@dataclass
class ClusterIssuerStatus:
    """Status of a cert-manager ClusterIssuer."""

    exists: bool
    ready: bool
    message: str = ""

# =============================================================================
# Abstract Controller
# =============================================================================

class KubernetesController(ABC):
    """Abstract base class for Kubernetes operations.

    All methods are async to support both sync (kubectl) and async (kr8s)
    implementations. Use `run_sync()` to call from synchronous code.
    """

    async def apply_manifest(self, manifest_path: Path) -> CommandResult: ...
    async def check_cert_manager_installed(
        self,
    ) -> bool: ...
    async def delete_helm_secrets(
        self, namespace: str, release_name: str
    ) -> CommandResult: ...
    async def delete_namespace(
        self, namespace: str, *, wait: bool = True, timeout: str = "120s"
    ) -> CommandResult: ...
    async def delete_pvcs(self, namespace: str) -> CommandResult: ...
    async def delete_replicaset(self, name: str, namespace: str) -> CommandResult: ...
    async def delete_resource(
        self,
        resource_type: str,
        name: str,
        namespace: str,
        *,
        cascade: str | None = None,
        wait: bool = True,
    ) -> CommandResult: ...
    async def delete_resources_by_label(
        self,
        resource_types: str,
        namespace: str,
        label_selector: str,
        *,
        force: bool = False,
        cascade: str | None = None,
    ) -> CommandResult: ...
    async def get_cluster_issuer_status(
        self, issuer_name: str
    ) -> ClusterIssuerStatus: ...
    async def get_cluster_issuer_yaml(self, issuer_name: str) -> str | None: ...
    async def get_current_context(
        self,
    ) -> str: ...
    async def get_deployment_revision(
        self, name: str, namespace: str
    ) -> str | None: ...
    async def get_deployments(self, namespace: str) -> list[str]: ...
    async def get_jobs(self, namespace: str) -> list[JobInfo]: ...
    async def get_pod_logs(
        self,
        namespace: str,
        pod: str | None = None,
        *,
        container: str | None = None,
        label_selector: str | None = None,
        follow: bool = False,
        tail: int = 100,
        previous: bool = False,
    ) -> CommandResult: ...
    async def get_pods(
        self, namespace: str, label_selector: str | None = None
    ) -> list[PodInfo]: ...
    async def get_replicasets(self, namespace: str) -> list[ReplicaSetInfo]: ...
    async def get_services(self, namespace: str) -> list[ServiceInfo]: ...
    async def is_minikube_context(
        self,
    ) -> bool: ...
    async def namespace_exists(self, namespace: str) -> bool: ...
    async def resource_exists(
        self, resource_type: str, name: str, namespace: str
    ) -> bool: ...
    async def rollout_restart(
        self, resource_type: str, namespace: str, name: str | None = None
    ) -> CommandResult: ...
    async def rollout_status(
        self,
        resource_type: str,
        namespace: str,
        name: str | None = None,
        *,
        timeout: str = "300s",
    ) -> CommandResult: ...
    async def scale_replicaset(
        self, name: str, namespace: str, replicas: int
    ) -> CommandResult: ...
    async def wait_for_pods(
        self,
        namespace: str,
        label_selector: str,
        *,
        condition: str = "ready",
        timeout: str = "300s",
    ) -> CommandResult: ...

# =============================================================================
# Synchronous Wrapper
# =============================================================================

class KubernetesControllerSync:
    """Synchronous wrapper for KubernetesController with full type hints.

    All async methods from KubernetesController are exposed as synchronous methods.
    The underlying async controller is wrapped automatically using run_sync().
    """

    def __init__(self, controller: KubernetesController) -> None:
        """Initialize the synchronous wrapper.

        Args:
            controller: The underlying async KubernetesController instance
        """
        ...

    def apply_manifest(self, manifest_path: Path) -> CommandResult: ...
    def check_cert_manager_installed(
        self,
    ) -> bool: ...
    def delete_helm_secrets(
        self, namespace: str, release_name: str
    ) -> CommandResult: ...
    def delete_namespace(
        self, namespace: str, *, wait: bool = True, timeout: str = "120s"
    ) -> CommandResult: ...
    def delete_pvcs(self, namespace: str) -> CommandResult: ...
    def delete_replicaset(self, name: str, namespace: str) -> CommandResult: ...
    def delete_resource(
        self,
        resource_type: str,
        name: str,
        namespace: str,
        *,
        cascade: str | None = None,
        wait: bool = True,
    ) -> CommandResult: ...
    def delete_resources_by_label(
        self,
        resource_types: str,
        namespace: str,
        label_selector: str,
        *,
        force: bool = False,
        cascade: str | None = None,
    ) -> CommandResult: ...
    def get_cluster_issuer_status(self, issuer_name: str) -> ClusterIssuerStatus: ...
    def get_cluster_issuer_yaml(self, issuer_name: str) -> str | None: ...
    def get_current_context(
        self,
    ) -> str: ...
    def get_deployment_revision(self, name: str, namespace: str) -> str | None: ...
    def get_deployments(self, namespace: str) -> list[str]: ...
    def get_jobs(self, namespace: str) -> list[JobInfo]: ...
    def get_pod_logs(
        self,
        namespace: str,
        pod: str | None = None,
        *,
        container: str | None = None,
        label_selector: str | None = None,
        follow: bool = False,
        tail: int = 100,
        previous: bool = False,
    ) -> CommandResult: ...
    def get_pods(
        self, namespace: str, label_selector: str | None = None
    ) -> list[PodInfo]: ...
    def get_replicasets(self, namespace: str) -> list[ReplicaSetInfo]: ...
    def get_services(self, namespace: str) -> list[ServiceInfo]: ...
    def is_minikube_context(
        self,
    ) -> bool: ...
    def namespace_exists(self, namespace: str) -> bool: ...
    def resource_exists(
        self, resource_type: str, name: str, namespace: str
    ) -> bool: ...
    def rollout_restart(
        self, resource_type: str, namespace: str, name: str | None = None
    ) -> CommandResult: ...
    def rollout_status(
        self,
        resource_type: str,
        namespace: str,
        name: str | None = None,
        *,
        timeout: str = "300s",
    ) -> CommandResult: ...
    def scale_replicaset(
        self, name: str, namespace: str, replicas: int
    ) -> CommandResult: ...
    def wait_for_pods(
        self,
        namespace: str,
        label_selector: str,
        *,
        condition: str = "ready",
        timeout: str = "300s",
    ) -> CommandResult: ...
