# =============================================================================
# API Forge Helm Chart Values
# =============================================================================
# Production-ready defaults with autoscaling and pod disruption budgets.
# Adjust values based on your workload requirements.
#
# Resource Sizing Guide:
#   Low Traffic (<100 req/s):   app: 250m/256Mi, 1 replica
#   Medium Traffic (100-500):   app: 500m/512Mi, 2-3 replicas, HPA enabled
#   High Traffic (>500 req/s):  app: 1000m/1Gi, 3+ replicas, HPA enabled
# =============================================================================

global:
  namespace: api-forge-prod
  createNamespace: false
  environment: production
  namePrefix: api-forge
  imageRegistry: ''
  imagePullPolicy: IfNotPresent
  labels:
    environment: production
    app.kubernetes.io/managed-by: helm

# =============================================================================
# PostgreSQL Database
# =============================================================================
# For production, consider using a managed PostgreSQL service (RDS, Cloud SQL)
# instead of running PostgreSQL in-cluster for better HA and backup support.
postgres:
  enabled: true
  image:
    repository: app_data_postgres_image
    tag: latest
  replicas: 1
  database: appdb
  username: appuser
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 4Gi
  persistence:
    data:
      enabled: true
      size: 20Gi
      storageClass: ''
    backups:
      enabled: true
      size: 40Gi
      storageClass: ''
  config:
    maxConnections: 200
    sharedBuffers: 256MB
    effectiveCacheSize: 1GB
  tls:
    enabled: true
    existingSecret: postgres-tls
  ca:
    existingSecret: postgres-ca
  secrets:
    existingSecret: postgres-secrets
  # PodDisruptionBudget - ensures database availability during maintenance
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  networkPolicy:
    enabled: true
    ingress:
    - from:
      - podSelector:
          matchLabels:
            app.kubernetes.io/component: application
      ports:
      - protocol: TCP
        port: 5432

# =============================================================================
# Redis Cache/Sessions
# =============================================================================
redis:
  enabled: true
  image:
    repository: app_data_redis_image
    tag: latest
  replicas: 1
  resources:
    requests:
      cpu: 250m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi
  persistence:
    data:
      enabled: true
      size: 5Gi
      storageClass: ''
    backups:
      enabled: true
      size: 10Gi
      storageClass: ''
  config:
    maxMemory: 512mb
    maxMemoryPolicy: allkeys-lru
  secrets:
    existingSecret: redis-secrets
  # PodDisruptionBudget
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  networkPolicy:
    enabled: true
    ingress:
    - from:
      - podSelector:
          matchLabels:
            app.kubernetes.io/component: application

# =============================================================================
# Temporal Workflow Engine
# =============================================================================
temporal:
  enabled: true
  image:
    repository: my-temporal-server
    tag: latest
  replicas: 1
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 4Gi
  persistence:
    certs:
      enabled: true
      size: 1Gi
      storageClass: ''
  config:
    services: history,matching,worker,frontend
    numHistoryShards: 64
  web:
    enabled: true
    image: temporalio/ui:latest
    replicas: 1
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi
  jobs:
    schemaSetup:
      enabled: true
      image: temporalio/admin-tools:latest
      backoffLimit: 3
      ttlSecondsAfterFinished: 300
    namespaceInit:
      enabled: true
      image: temporalio/admin-tools:latest
      backoffLimit: 3
      ttlSecondsAfterFinished: 300
  # PodDisruptionBudget
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  networkPolicy:
    enabled: true
    ingress:
    - from:
      - podSelector:
          matchLabels:
            app.kubernetes.io/component: application
      ports:
      - protocol: TCP
        port: 7233

# =============================================================================
# FastAPI Application
# =============================================================================
app:
  enabled: true
  name: app
  image:
    repository: api-forge-app
    tag: latest
    pullPolicy: IfNotPresent
  # Base replicas (used when autoscaling is disabled)
  replicas: 1
  revisionHistoryLimit: 3
  resources:
    requests:
      cpu: 250m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi
  persistence:
    logs:
      enabled: true
      size: 5Gi
      storageClass: ''
  env:
    APP_ENVIRONMENT: production
    APP_HOST: 0.0.0.0
    APP_PORT: '8000'
    LOG_FORMAT: json
    LOG_LEVEL: INFO
  config:
    fromFile: true
  secrets:
    existingSecret: app-secrets
  service:
    type: ClusterIP
    port: 8000
  ingress:
    enabled: false
    className: nginx
    annotations: {}
    hosts:
    - host: api-forge.local
      paths:
      - path: /
        pathType: Prefix
    tls: []
  # Horizontal Pod Autoscaler
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
    behavior:
      scaleDown:
        stabilizationWindowSeconds: 300
        percentValue: 10
        periodSeconds: 60
      scaleUp:
        stabilizationWindowSeconds: 0
        percentValue: 100
        podsValue: 4
        periodSeconds: 15
  # PodDisruptionBudget - ensures app availability during maintenance
  # Use maxUnavailable (not minAvailable) to work with single-replica deployments
  podDisruptionBudget:
    enabled: true
    maxUnavailable: 1
    # Alternatively, use minAvailable (but this blocks eviction when replicas=1):
    # minAvailable: 1
    # Alternatively, use maxUnavailable:
    # maxUnavailable: 1

# =============================================================================
# Temporal Worker
# =============================================================================
worker:
  enabled: true
  image:
    repository: api-forge-app
    tag: latest
    pullPolicy: IfNotPresent
  # Base replicas (used when autoscaling is disabled)
  replicas: 1
  revisionHistoryLimit: 3
  resources:
    requests:
      cpu: 250m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi
  # Horizontal Pod Autoscaler
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
    behavior:
      scaleDown:
        # Workers scale down more conservatively to avoid disrupting workflows
        stabilizationWindowSeconds: 600
        percentValue: 10
        periodSeconds: 120
      scaleUp:
        stabilizationWindowSeconds: 0
        percentValue: 100
        podsValue: 2
        periodSeconds: 15
  # PodDisruptionBudget
  # Use maxUnavailable (not minAvailable) to work with single-replica deployments
  podDisruptionBudget:
    enabled: true
    maxUnavailable: 1

# =============================================================================
# Initialization Jobs
# =============================================================================
jobs:
  postgresVerifier:
    enabled: true
    image: app_data_postgres_image
    backoffLimit: 3
    ttlSecondsAfterFinished: 300
  temporalSchemaSetup:
    enabled: true
    image: temporalio/admin-tools:latest
    backoffLimit: 3
    ttlSecondsAfterFinished: 300
  temporalNamespaceInit:
    enabled: true
    image: temporalio/admin-tools:latest
    backoffLimit: 3
    ttlSecondsAfterFinished: 300
